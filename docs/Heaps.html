<p><img src="https://github.com/user-attachments/assets/10bfa27c-1183-4718-8d5b-3e6c089dc59f" alt="picture2" /></p>
<h1>Attributes</h1>
<p>A Heap is a specialized binary tree-based data structure that satisfies the heap property:</p>
<ul>
<li>Min-Heap: The value of each node is less than or equal to the values of its children. Hence, the smallest element is at the root.</li>
<li>Max-Heap: The value of each node is greater than or equal to the values of its children. Hence, the largest element is at the root.</li>
</ul>
<p>Additional Attributes:</p>
<ul>
<li>Complete Binary Tree: Heaps are complete binary trees, meaning all levels are fully filled except possibly the last, which is filled from left to right.</li>
<li>Efficiently Implemented Using Arrays: Heaps can be stored in arrays, where for a node at index i, its left child is at 2i + 1 and right child at 2i + 2.</li>
</ul>
<h1>Operations</h1>
<p>| Operation            | Time Complexity | Description                                                        |
|----------------------|-----------------|--------------------------------------------------------------------|
| Insert (add element)  | O(log n)        | Insert an element at the end, then &quot;bubble up&quot; to maintain heap property. |
| Extract-Min/Max       | O(log n)        | Remove the root (min or max), replace it with the last element, then &quot;heapify&quot;. |
| Peek (Min/Max)        | O(1)            | Retrieve the root without removing it.                             |
| Heapify (build heap)  | O(n)            | Convert an unsorted array into a heap (faster than n * O(log n)).   |
| Delete                | O(log n)        | Remove an arbitrary element and restore the heap property.          |
| Decrease/Increase Key | O(log n)        | Modify a key and adjust heap to restore the heap property.          |
| Build Heap | O(n) | Creating a heap from an unsorted array |</p>
<h1>Trade Offs</h1>
<p>| PRO                                        | CON                                                          |
|--------------------------------------------|---------------------------------------------------------------|
| Efficient O(1) access to min/max element    | Limited to fast access only for min/max; not suitable for arbitrary searches |
| O(log n) insertions and deletions          | Insertion/removal is slower than simpler structures like arrays or linked lists |
| Space-efficient array representation       | Not as flexible or easy to traverse as other binary tree structures |
| Optimal for priority queue operations      | Less efficient for full sorting compared to some other algorithms (e.g., Quicksort) |
| Useful in graph algorithms (Dijkstra, Prim) | Heap operations can become costly if constant rebalancing is needed in dynamic scenarios |</p>
<h1>Common Uses</h1>
<ol>
<li>
<p><strong>Priority Queues</strong>: Heaps are widely used to implement priority queues, where elements are dequeued based on priority (min or max).</p>
</li>
<li>
<p><strong>Graph Algorithms</strong>:</p>
<ul>
<li><strong>Dijkstra's Algorithm</strong>: Min-heaps are used to efficiently fetch the next closest node.</li>
<li><strong>Prim's Algorithm</strong>: Heaps help efficiently select the minimum-weight edge.</li>
</ul>
</li>
<li>
<p><strong>Heap Sort</strong>: Heaps can be used to sort data in O(n log n) time through Heapsort. This involves building a min/max heap &amp; then extracting the next min/max element to produce a sorted array.</p>
</li>
<li>
<p><strong>Scheduling Systems</strong>: Heaps can manage tasks with varying priorities in operating systems or task schedulers.</p>
</li>
<li>
<p><strong>Median Maintenance</strong>: Two heaps (a min-heap and a max-heap) can be used to maintain a dynamic set of numbers and quickly access the median.</p>
</li>
</ol>
<h1>Implementations</h1>
<p><a href="https://github.com/mc-0/DSA/blob/main/src/datastructures/heaps/Heap.java">Heap Implementation</a></p>
